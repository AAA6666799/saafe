"""
Alert Generation Agent for the synthetic fire prediction system.

This module implements the AlertGenerationAgent class, which is responsible for
generating alerts based on fire detection and classification results.
"""

from typing import Dict, Any, List, Optional, Union
import numpy as np
from datetime import datetime
import logging
import uuid
import json

from ..base import Agent, Message

# Configure logging
logger = logging.getLogger(__name__)


class Alert:
    """
    Class representing an alert generated by the system.
    """
    
    # Alert levels
    LEVEL_INFO = "info"
    LEVEL_WARNING = "warning"
    LEVEL_CRITICAL = "critical"
    LEVEL_EMERGENCY = "emergency"
    
    def __init__(self, 
                alert_id: str,
                timestamp: datetime,
                level: str,
                message: str,
                source_agent_id: str,
                fire_detected: bool = False,
                fire_type: Optional[str] = None,
                severity: Optional[int] = None,
                confidence: float = 0.0,
                location: Optional[str] = None,
                metadata: Optional[Dict[str, Any]] = None):
        """
        Initialize an alert.
        
        Args:
            alert_id: Unique identifier for the alert
            timestamp: Time when the alert was generated
            level: Alert level (info, warning, critical, emergency)
            message: Alert message
            source_agent_id: ID of the agent that generated the alert
            fire_detected: Whether a fire was detected
            fire_type: Type of fire if detected
            severity: Severity of the fire if detected
            confidence: Confidence in the alert
            location: Location of the alert
            metadata: Additional metadata for the alert
        """
        self.alert_id = alert_id
        self.timestamp = timestamp
        self.level = level
        self.message = message
        self.source_agent_id = source_agent_id
        self.fire_detected = fire_detected
        self.fire_type = fire_type
        self.severity = severity
        self.confidence = confidence
        self.location = location
        self.metadata = metadata or {}
        self.acknowledged = False
        self.acknowledged_time = None
        self.acknowledged_by = None
    
    def acknowledge(self, user_id: str) -> None:
        """
        Acknowledge the alert.
        
        Args:
            user_id: ID of the user acknowledging the alert
        """
        self.acknowledged = True
        self.acknowledged_time = datetime.now()
        self.acknowledged_by = user_id
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the alert to a dictionary.
        
        Returns:
            Dictionary representation of the alert
        """
        return {
            "alert_id": self.alert_id,
            "timestamp": self.timestamp.isoformat(),
            "level": self.level,
            "message": self.message,
            "source_agent_id": self.source_agent_id,
            "fire_detected": self.fire_detected,
            "fire_type": self.fire_type,
            "severity": self.severity,
            "confidence": self.confidence,
            "location": self.location,
            "metadata": self.metadata,
            "acknowledged": self.acknowledged,
            "acknowledged_time": self.acknowledged_time.isoformat() if self.acknowledged_time else None,
            "acknowledged_by": self.acknowledged_by
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Alert':
        """
        Create an alert from a dictionary.
        
        Args:
            data: Dictionary representation of an alert
            
        Returns:
            Alert instance
        """
        alert = cls(
            alert_id=data["alert_id"],
            timestamp=datetime.fromisoformat(data["timestamp"]),
            level=data["level"],
            message=data["message"],
            source_agent_id=data["source_agent_id"],
            fire_detected=data["fire_detected"],
            fire_type=data["fire_type"],
            severity=data["severity"],
            confidence=data["confidence"],
            location=data["location"],
            metadata=data["metadata"]
        )
        
        alert.acknowledged = data["acknowledged"]
        if data["acknowledged_time"]:
            alert.acknowledged_time = datetime.fromisoformat(data["acknowledged_time"])
        alert.acknowledged_by = data["acknowledged_by"]
        
        return alert


class AlertGenerationAgent(Agent):
    """
    Agent responsible for generating alerts based on fire detection and classification.
    
    This agent analyzes fire detection and classification results to generate
    appropriate alerts with different severity levels.
    """
    
    def __init__(self, agent_id: str, config: Dict[str, Any]):
        """
        Initialize the alert generation agent.
        
        Args:
            agent_id: Unique identifier for the agent
            config: Dictionary containing configuration parameters
        """
        super().__init__(agent_id, config)
        
        # Initialize alert thresholds
        self.severity_thresholds = {
            Alert.LEVEL_INFO: config.get("info_threshold", 1),
            Alert.LEVEL_WARNING: config.get("warning_threshold", 3),
            Alert.LEVEL_CRITICAL: config.get("critical_threshold", 6),
            Alert.LEVEL_EMERGENCY: config.get("emergency_threshold", 8)
        }
        
        self.confidence_threshold = config.get("confidence_threshold", 0.5)
        
        # Initialize FLIR+SCD41 specific thresholds
        self.flir_thresholds = config.get("flir_thresholds", {
            "t_max": 60.0,      # °C
            "t_hot_area_pct": 10.0,  # %
            "tproxy_vel": 2.0   # Rate of change
        })
        
        self.scd41_thresholds = config.get("scd41_thresholds", {
            "gas_val": 1000.0,   # ppm CO₂
            "gas_delta": 50.0,   # ppm change
            "gas_vel": 50.0     # Rate of change
        })
        
        # Initialize alert state
        self.alerts = []
        self.active_alerts = {}  # alert_id -> Alert
        self.alert_count = 0
        
        # Initialize location information
        self.location = config.get("location", "Unknown")
        
        # Register message handlers
        self.register_message_handler("update_thresholds", self._handle_update_thresholds)
        self.register_message_handler("acknowledge_alert", self._handle_acknowledge_alert)
    
    def validate_config(self) -> None:
        """
        Validate the configuration parameters.
        
        Raises:
            ValueError: If configuration is invalid
        """
        # Validate threshold values
        for level, threshold in self.severity_thresholds.items():
            if not isinstance(threshold, (int, float)) or threshold < 0:
                raise ValueError(f"Severity threshold for {level} must be a non-negative number, got {threshold}")
        
        if "confidence_threshold" in self.config:
            threshold = self.config["confidence_threshold"]
            if not 0 <= threshold <= 1:
                raise ValueError(f"Confidence threshold must be between 0 and 1, got {threshold}")
    
    def process(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process input data and generate alerts.
        
        Args:
            data: Input data containing fire detection and classification results
            
        Returns:
            Dictionary containing alert generation results
        """
        try:
            # Check if fire is detected
            fire_detected = data.get("is_fire_detected", False)
            
            # If no fire detected, check if we need to generate an all-clear alert
            if not fire_detected:
                if self._should_generate_all_clear():
                    alert = self._generate_all_clear_alert()
                    return {
                        "timestamp": datetime.now().isoformat(),
                        "alert_generated": True,
                        "alert": alert.to_dict()
                    }
                else:
                    return {
                        "timestamp": datetime.now().isoformat(),
                        "alert_generated": False
                    }
            
            # Extract fire information
            fire_type = data.get("fire_type", "unknown")
            severity = data.get("severity", 0)
            confidence = data.get("confidence", 0.0)
            
            # Check if confidence is high enough
            if confidence < self.confidence_threshold:
                logger.info(f"Fire detection confidence {confidence} below threshold {self.confidence_threshold}, no alert generated")
                return {
                    "timestamp": datetime.now().isoformat(),
                    "alert_generated": False,
                    "reason": "confidence_below_threshold"
                }
            
            # Determine alert level based on severity
            alert_level = self._determine_alert_level(severity)
            
            # Generate alert message
            message = self._generate_alert_message(fire_type, severity, alert_level)
            
            # Create alert
            alert = Alert(
                alert_id=str(uuid.uuid4()),
                timestamp=datetime.now(),
                level=alert_level,
                message=message,
                source_agent_id=self.agent_id,
                fire_detected=True,
                fire_type=fire_type,
                severity=severity,
                confidence=confidence,
                location=self.location,
                metadata={
                    "characteristics": data.get("characteristics", {}),
                    "raw_data": {
                        "flir": data.get("flir", {}),
                        "scd41": data.get("scd41", {})
                    }
                }
            )
            
            # Store alert
            self.alerts.append(alert)
            self.active_alerts[alert.alert_id] = alert
            self.alert_count += 1
            
            # Log alert
            log_method = logger.warning if alert_level in [Alert.LEVEL_WARNING, Alert.LEVEL_INFO] else logger.error
            log_method(f"Generated {alert_level} alert: {message}")
            
            # Limit alerts history
            max_history = self.config.get("max_history_size", 1000)
            if len(self.alerts) > max_history:
                self.alerts = self.alerts[-max_history:]
            
            return {
                "timestamp": datetime.now().isoformat(),
                "alert_generated": True,
                "alert": alert.to_dict()
            }
        except Exception as e:
            logger.error(f"Error in alert generation processing: {e}")
            return {
                "timestamp": datetime.now().isoformat(),
                "error": str(e),
                "alert_generated": False
            }
    
    def _determine_alert_level(self, severity: int) -> str:
        """
        Determine the alert level based on fire severity.
        
        Args:
            severity: Fire severity (1-10)
            
        Returns:
            Alert level
        """
        if severity >= self.severity_thresholds[Alert.LEVEL_EMERGENCY]:
            return Alert.LEVEL_EMERGENCY
        elif severity >= self.severity_thresholds[Alert.LEVEL_CRITICAL]:
            return Alert.LEVEL_CRITICAL
        elif severity >= self.severity_thresholds[Alert.LEVEL_WARNING]:
            return Alert.LEVEL_WARNING
        else:
            return Alert.LEVEL_INFO
    
    def _generate_alert_message(self, fire_type: str, severity: int, alert_level: str) -> str:
        """
        Generate an alert message based on fire type, severity, and alert level.
        
        Args:
            fire_type: Type of fire
            severity: Fire severity (1-10)
            alert_level: Alert level
            
        Returns:
            Alert message
        """
        if alert_level == Alert.LEVEL_EMERGENCY:
            return f"EMERGENCY: {fire_type.upper()} fire detected with severity {severity}/10. Immediate evacuation required."
        elif alert_level == Alert.LEVEL_CRITICAL:
            return f"CRITICAL: {fire_type.capitalize()} fire detected with severity {severity}/10. Prepare for evacuation."
        elif alert_level == Alert.LEVEL_WARNING:
            return f"WARNING: Possible {fire_type} fire detected with severity {severity}/10. Investigate immediately."
        else:
            return f"INFO: Potential {fire_type} fire signature detected with severity {severity}/10. Monitor situation."
    
    def _should_generate_all_clear(self) -> bool:
        """
        Determine if an all-clear alert should be generated.
        
        Returns:
            True if an all-clear alert should be generated, False otherwise
        """
        # Check if there are any active alerts
        if not self.active_alerts:
            return False
        
        # Check if enough time has passed since the last alert
        all_clear_delay = self.config.get("all_clear_delay_seconds", 300)  # 5 minutes default
        now = datetime.now()
        
        # Find the most recent active alert
        most_recent = max(self.active_alerts.values(), key=lambda a: a.timestamp)
        seconds_since_last_alert = (now - most_recent.timestamp).total_seconds()
        
        return seconds_since_last_alert >= all_clear_delay
    
    def _generate_all_clear_alert(self) -> Alert:
        """
        Generate an all-clear alert.
        
        Returns:
            All-clear alert
        """
        alert = Alert(
            alert_id=str(uuid.uuid4()),
            timestamp=datetime.now(),
            level=Alert.LEVEL_INFO,
            message="ALL CLEAR: No fire detected. Previous alerts have been resolved.",
            source_agent_id=self.agent_id,
            fire_detected=False,
            location=self.location
        )
        
        # Store alert
        self.alerts.append(alert)
        
        # Clear active alerts
        self.active_alerts = {}
        
        logger.info("Generated all-clear alert")
        
        return alert
    
    def _handle_update_thresholds(self, message: Message) -> Optional[Message]:
        """
        Handle a message to update alert thresholds.
        
        Args:
            message: Message containing new threshold values
            
        Returns:
            Optional response message
        """
        content = message.content
        updated = False
        
        # Update severity thresholds
        for level in [Alert.LEVEL_INFO, Alert.LEVEL_WARNING, Alert.LEVEL_CRITICAL, Alert.LEVEL_EMERGENCY]:
            threshold_key = f"{level}_threshold"
            if threshold_key in content:
                new_threshold = content[threshold_key]
                if isinstance(new_threshold, (int, float)) and new_threshold >= 0:
                    self.severity_thresholds[level] = new_threshold
                    updated = True
                    logger.info(f"Updated {level} threshold to {new_threshold}")
                else:
                    logger.error(f"Invalid {level} threshold: {new_threshold}")
        
        # Update confidence threshold
        if "confidence_threshold" in content:
            new_threshold = content["confidence_threshold"]
            if 0 <= new_threshold <= 1:
                self.confidence_threshold = new_threshold
                updated = True
                logger.info(f"Updated confidence threshold to {new_threshold}")
            else:
                logger.error(f"Invalid confidence threshold: {new_threshold}")
        
        # Update FLIR thresholds
        if "flir_thresholds" in content:
            new_thresholds = content["flir_thresholds"]
            if isinstance(new_thresholds, dict):
                self.flir_thresholds.update(new_thresholds)
                updated = True
                logger.info(f"Updated FLIR thresholds: {new_thresholds}")
            else:
                logger.error(f"Invalid FLIR thresholds: {new_thresholds}")
        
        # Update SCD41 thresholds
        if "scd41_thresholds" in content:
            new_thresholds = content["scd41_thresholds"]
            if isinstance(new_thresholds, dict):
                self.scd41_thresholds.update(new_thresholds)
                updated = True
                logger.info(f"Updated SCD41 thresholds: {new_thresholds}")
            else:
                logger.error(f"Invalid SCD41 thresholds: {new_thresholds}")
        
        # Send acknowledgment
        if updated:
            return self.create_message(
                message.sender_id,
                "threshold_update_ack",
                {
                    "severity_thresholds": self.severity_thresholds,
                    "confidence_threshold": self.confidence_threshold,
                    "flir_thresholds": self.flir_thresholds,
                    "scd41_thresholds": self.scd41_thresholds
                }
            )
        else:
            return None
    
    def _handle_acknowledge_alert(self, message: Message) -> Optional[Message]:
        """
        Handle a message to acknowledge an alert.
        
        Args:
            message: Message containing alert acknowledgment
            
        Returns:
            Optional response message
        """
        content = message.content
        
        if "alert_id" not in content or "user_id" not in content:
            logger.error("Missing alert_id or user_id in acknowledge_alert message")
            return self.create_message(
                message.sender_id,
                "acknowledge_alert_nack",
                {
                    "error": "Missing alert_id or user_id"
                }
            )
        
        alert_id = content["alert_id"]
        user_id = content["user_id"]
        
        if alert_id in self.active_alerts:
            alert = self.active_alerts[alert_id]
            alert.acknowledge(user_id)
            
            # Remove from active alerts
            del self.active_alerts[alert_id]
            
            logger.info(f"Alert {alert_id} acknowledged by {user_id}")
            
            return self.create_message(
                message.sender_id,
                "acknowledge_alert_ack",
                {
                    "alert_id": alert_id,
                    "acknowledged": True,
                    "acknowledged_time": alert.acknowledged_time.isoformat(),
                    "acknowledged_by": alert.acknowledged_by
                }
            )
        else:
            logger.warning(f"Attempt to acknowledge unknown alert {alert_id}")
            
            return self.create_message(
                message.sender_id,
                "acknowledge_alert_nack",
                {
                    "alert_id": alert_id,
                    "error": "Alert not found or already acknowledged"
                }
            )
    
    def default_message_handler(self, message: Message) -> Optional[Message]:
        """
        Default handler for message types without a specific handler.
        
        Args:
            message: Incoming message
            
        Returns:
            Optional response message
        """
        logger.warning(f"Received unhandled message type: {message.message_type}")
        return None
    
    def create_message(self, receiver_id: str, message_type: str, content: Dict[str, Any], priority: int = 0) -> Message:
        """
        Create a new message to send to another agent.
        
        Args:
            receiver_id: ID of the receiving agent
            message_type: Type of message
            content: Message content
            priority: Message priority
            
        Returns:
            Created message
        """
        return Message(self.agent_id, receiver_id, message_type, content, priority)
    
    def save_state(self, filepath: str) -> None:
        """
        Save the agent's state to a file.
        
        Args:
            filepath: Path to save the state
        """
        state = {
            "severity_thresholds": self.severity_thresholds,
            "confidence_threshold": self.confidence_threshold,
            "flir_thresholds": self.flir_thresholds,
            "scd41_thresholds": self.scd41_thresholds,
            "location": self.location,
            "alert_count": self.alert_count,
            "alerts": [alert.to_dict() for alert in self.alerts],
            "active_alerts": [alert.to_dict() for alert in self.active_alerts.values()]
        }
        
        with open(filepath, 'w') as f:
            json.dump(state, f, indent=2)
    
    def load_state(self, filepath: str) -> None:
        """
        Load the agent's state from a file.
        
        Args:
            filepath: Path to load the state from
        """
        with open(filepath, 'r') as f:
            state = json.load(f)
        
        self.severity_thresholds = state["severity_thresholds"]
        self.confidence_threshold = state["confidence_threshold"]
        self.flir_thresholds = state["flir_thresholds"]
        self.scd41_thresholds = state["scd41_thresholds"]
        self.location = state["location"]
        self.alert_count = state["alert_count"]
        
        self.alerts = [Alert.from_dict(alert_dict) for alert_dict in state["alerts"]]
        
        self.active_alerts = {}
        for alert_dict in state["active_alerts"]:
            alert = Alert.from_dict(alert_dict)
            self.active_alerts[alert.alert_id] = alert