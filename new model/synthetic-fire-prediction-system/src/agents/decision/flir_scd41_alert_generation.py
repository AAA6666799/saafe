"""
FLIR+SCD41 Alert Generation Agent for the synthetic fire prediction system.

This module implements the FLIRSCD41AlertGenerationAgent class, which is responsible for
generating alerts based on FLIR Lepton 3.5 thermal camera and SCD41 CO₂ sensor data.
"""

from typing import Dict, Any, List, Optional, Union
import numpy as np
from datetime import datetime
import logging
import uuid
import json

from ..base import Agent, Message

# Configure logging
logger = logging.getLogger(__name__)


class FLIRSCD41Alert:
    """
    Class representing an alert generated by the FLIR+SCD41 system.
    """
    
    # Alert levels
    LEVEL_INFO = "info"
    LEVEL_WARNING = "warning"
    LEVEL_CRITICAL = "critical"
    LEVEL_EMERGENCY = "emergency"
    
    def __init__(self, 
                alert_id: str,
                timestamp: datetime,
                level: str,
                message: str,
                source_agent_id: str,
                fire_detected: bool = False,
                fire_type: Optional[str] = None,
                severity: Optional[int] = None,
                confidence: float = 0.0,
                location: Optional[str] = None,
                flir_data: Optional[Dict[str, Any]] = None,
                scd41_data: Optional[Dict[str, Any]] = None,
                metadata: Optional[Dict[str, Any]] = None):
        """
        Initialize an FLIR+SCD41 alert.
        
        Args:
            alert_id: Unique identifier for the alert
            timestamp: Time when the alert was generated
            level: Alert level (info, warning, critical, emergency)
            message: Alert message
            source_agent_id: ID of the agent that generated the alert
            fire_detected: Whether a fire was detected
            fire_type: Type of fire if detected
            severity: Severity of the fire if detected
            confidence: Confidence in the alert
            location: Location of the alert
            flir_data: FLIR thermal sensor data that triggered the alert
            scd41_data: SCD41 gas sensor data that triggered the alert
            metadata: Additional metadata for the alert
        """
        self.alert_id = alert_id
        self.timestamp = timestamp
        self.level = level
        self.message = message
        self.source_agent_id = source_agent_id
        self.fire_detected = fire_detected
        self.fire_type = fire_type
        self.severity = severity
        self.confidence = confidence
        self.location = location
        self.flir_data = flir_data or {}
        self.scd41_data = scd41_data or {}
        self.metadata = metadata or {}
        self.acknowledged = False
        self.acknowledged_time = None
        self.acknowledged_by = None
    
    def acknowledge(self, user_id: str) -> None:
        """
        Acknowledge the alert.
        
        Args:
            user_id: ID of the user acknowledging the alert
        """
        self.acknowledged = True
        self.acknowledged_time = datetime.now()
        self.acknowledged_by = user_id
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the alert to a dictionary.
        
        Returns:
            Dictionary representation of the alert
        """
        return {
            "alert_id": self.alert_id,
            "timestamp": self.timestamp.isoformat(),
            "level": self.level,
            "message": self.message,
            "source_agent_id": self.source_agent_id,
            "fire_detected": self.fire_detected,
            "fire_type": self.fire_type,
            "severity": self.severity,
            "confidence": self.confidence,
            "location": self.location,
            "flir_data": self.flir_data,
            "scd41_data": self.scd41_data,
            "metadata": self.metadata,
            "acknowledged": self.acknowledged,
            "acknowledged_time": self.acknowledged_time.isoformat() if self.acknowledged_time else None,
            "acknowledged_by": self.acknowledged_by
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'FLIRSCD41Alert':
        """
        Create an alert from a dictionary.
        
        Args:
            data: Dictionary representation of an alert
            
        Returns:
            FLIRSCD41Alert instance
        """
        alert = cls(
            alert_id=data["alert_id"],
            timestamp=datetime.fromisoformat(data["timestamp"]),
            level=data["level"],
            message=data["message"],
            source_agent_id=data["source_agent_id"],
            fire_detected=data["fire_detected"],
            fire_type=data["fire_type"],
            severity=data["severity"],
            confidence=data["confidence"],
            location=data["location"],
            flir_data=data["flir_data"],
            scd41_data=data["scd41_data"],
            metadata=data["metadata"]
        )
        
        alert.acknowledged = data["acknowledged"]
        if data["acknowledged_time"]:
            alert.acknowledged_time = datetime.fromisoformat(data["acknowledged_time"])
        alert.acknowledged_by = data["acknowledged_by"]
        
        return alert


class FLIRSCD41AlertGenerationAgent(Agent):
    """
    Agent responsible for generating alerts based on FLIR+SCD41 sensor data.
    
    This agent analyzes FLIR thermal camera and SCD41 CO₂ sensor data to generate
    appropriate alerts with different severity levels based on specific thresholds
    for each sensor type.
    """
    
    def __init__(self, agent_id: str, config: Dict[str, Any]):
        """
        Initialize the FLIR+SCD41 alert generation agent.
        
        Args:
            agent_id: Unique identifier for the agent
            config: Dictionary containing configuration parameters
        """
        super().__init__(agent_id, config)
        
        # Initialize alert thresholds
        self.severity_thresholds = {
            FLIRSCD41Alert.LEVEL_INFO: config.get("info_threshold", 1),
            FLIRSCD41Alert.LEVEL_WARNING: config.get("warning_threshold", 3),
            FLIRSCD41Alert.LEVEL_CRITICAL: config.get("critical_threshold", 6),
            FLIRSCD41Alert.LEVEL_EMERGENCY: config.get("emergency_threshold", 8)
        }
        
        self.confidence_threshold = config.get("confidence_threshold", 0.5)
        
        # Initialize FLIR+SCD41 specific thresholds
        self.flir_thresholds = config.get("flir_thresholds", {
            "t_max": 60.0,              # °C - Maximum temperature threshold
            "t_hot_area_pct": 10.0,     # % - Hot area percentage threshold
            "tproxy_vel": 2.0,          # Rate of temperature change
            "t_mean": 40.0,             # °C - Mean temperature threshold
            "t_std": 15.0               # °C - Temperature standard deviation threshold
        })
        
        self.scd41_thresholds = config.get("scd41_thresholds", {
            "gas_val": 1000.0,          # ppm CO₂ - CO₂ concentration threshold
            "gas_delta": 50.0,          # ppm change - CO₂ change threshold
            "gas_vel": 50.0,            # Rate of CO₂ change
            "co2_concentration": 1000.0 # ppm CO₂ - Alternative CO₂ concentration threshold
        })
        
        # Initialize alert state
        self.alerts = []
        self.active_alerts = {}  # alert_id -> FLIRSCD41Alert
        self.alert_count = 0
        
        # Initialize location information
        self.location = config.get("location", "Unknown")
        
        # Register message handlers
        self.register_message_handler("update_thresholds", self._handle_update_thresholds)
        self.register_message_handler("acknowledge_alert", self._handle_acknowledge_alert)
    
    def validate_config(self) -> None:
        """
        Validate the configuration parameters.
        
        Raises:
            ValueError: If configuration is invalid
        """
        # Validate threshold values
        for level, threshold in self.severity_thresholds.items():
            if not isinstance(threshold, (int, float)) or threshold < 0:
                raise ValueError(f"Severity threshold for {level} must be a non-negative number, got {threshold}")
        
        if "confidence_threshold" in self.config:
            threshold = self.config["confidence_threshold"]
            if not 0 <= threshold <= 1:
                raise ValueError(f"Confidence threshold must be between 0 and 1, got {threshold}")
    
    def process(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process FLIR+SCD41 sensor data and generate alerts.
        
        Args:
            data: Input data containing FLIR thermal and SCD41 gas sensor data
            
        Returns:
            Dictionary containing alert generation results
        """
        try:
            # Extract FLIR and SCD41 data
            flir_data = data.get("flir", {})
            scd41_data = data.get("scd41", {})
            
            # Check if we have any sensor data
            if not flir_data and not scd41_data:
                logger.info("No FLIR or SCD41 data received, no alert generated")
                return {
                    "timestamp": datetime.now().isoformat(),
                    "alert_generated": False,
                    "reason": "no_sensor_data"
                }
            
            # Analyze sensor data for fire signatures
            fire_analysis = self._analyze_fire_signature(flir_data, scd41_data)
            
            # If no fire detected, check if we need to generate an all-clear alert
            if not fire_analysis["fire_detected"]:
                if self._should_generate_all_clear():
                    alert = self._generate_all_clear_alert()
                    return {
                        "timestamp": datetime.now().isoformat(),
                        "alert_generated": True,
                        "alert": alert.to_dict()
                    }
                else:
                    return {
                        "timestamp": datetime.now().isoformat(),
                        "alert_generated": False
                    }
            
            # Extract fire information
            fire_type = fire_analysis["fire_type"]
            severity = fire_analysis["severity"]
            confidence = fire_analysis["confidence"]
            
            # Check if confidence is high enough
            if confidence < self.confidence_threshold:
                logger.info(f"Fire detection confidence {confidence} below threshold {self.confidence_threshold}, no alert generated")
                return {
                    "timestamp": datetime.now().isoformat(),
                    "alert_generated": False,
                    "reason": "confidence_below_threshold"
                }
            
            # Determine alert level based on severity
            alert_level = self._determine_alert_level(severity)
            
            # Generate alert message with sensor-specific information
            message = self._generate_alert_message(fire_type, severity, alert_level, flir_data, scd41_data)
            
            # Create alert
            alert = FLIRSCD41Alert(
                alert_id=str(uuid.uuid4()),
                timestamp=datetime.now(),
                level=alert_level,
                message=message,
                source_agent_id=self.agent_id,
                fire_detected=True,
                fire_type=fire_type,
                severity=severity,
                confidence=confidence,
                location=self.location,
                flir_data=flir_data,
                scd41_data=scd41_data,
                metadata={
                    "analysis": fire_analysis,
                    "raw_data_summary": {
                        "flir_sensor_count": len(flir_data),
                        "scd41_sensor_count": len(scd41_data)
                    }
                }
            )
            
            # Store alert
            self.alerts.append(alert)
            self.active_alerts[alert.alert_id] = alert
            self.alert_count += 1
            
            # Log alert
            log_method = logger.warning if alert_level in [FLIRSCD41Alert.LEVEL_WARNING, FLIRSCD41Alert.LEVEL_INFO] else logger.error
            log_method(f"Generated {alert_level} alert: {message}")
            
            # Limit alerts history
            max_history = self.config.get("max_history_size", 1000)
            if len(self.alerts) > max_history:
                self.alerts = self.alerts[-max_history:]
            
            return {
                "timestamp": datetime.now().isoformat(),
                "alert_generated": True,
                "alert": alert.to_dict()
            }
        except Exception as e:
            logger.error(f"Error in FLIR+SCD41 alert generation processing: {e}")
            return {
                "timestamp": datetime.now().isoformat(),
                "error": str(e),
                "alert_generated": False
            }
    
    def _analyze_fire_signature(self, flir_data: Dict[str, Any], scd41_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze FLIR and SCD41 data for fire signatures.
        
        Args:
            flir_data: FLIR thermal sensor data
            scd41_data: SCD41 gas sensor data
            
        Returns:
            Dictionary containing fire analysis results
        """
        # Initialize analysis results
        fire_detected = False
        fire_type = "unknown"
        severity = 0
        confidence = 0.0
        triggers = []
        
        # Analyze FLIR data
        flir_severity = 0
        flir_confidence = 0.0
        
        for sensor_id, sensor_data in flir_data.items():
            # Check temperature thresholds
            if "t_max" in sensor_data and sensor_data["t_max"] > self.flir_thresholds["t_max"]:
                fire_detected = True
                flir_severity = max(flir_severity, 7)
                flir_confidence = max(flir_confidence, 0.8)
                triggers.append(f"FLIR {sensor_id}: High temperature ({sensor_data['t_max']:.1f}°C)")
                fire_type = "thermal"
            
            if "t_hot_area_pct" in sensor_data and sensor_data["t_hot_area_pct"] > self.flir_thresholds["t_hot_area_pct"]:
                fire_detected = True
                flir_severity = max(flir_severity, 6)
                flir_confidence = max(flir_confidence, 0.7)
                triggers.append(f"FLIR {sensor_id}: Large hot area ({sensor_data['t_hot_area_pct']:.1f}%)")
                fire_type = "thermal"
            
            if "tproxy_vel" in sensor_data and sensor_data["tproxy_vel"] > self.flir_thresholds["tproxy_vel"]:
                fire_detected = True
                flir_severity = max(flir_severity, 5)
                flir_confidence = max(flir_confidence, 0.6)
                triggers.append(f"FLIR {sensor_id}: Rapid temperature change ({sensor_data['tproxy_vel']:.1f}°C/s)")
                fire_type = "thermal"
            
            if "t_mean" in sensor_data and sensor_data["t_mean"] > self.flir_thresholds["t_mean"]:
                fire_detected = True
                flir_severity = max(flir_severity, 4)
                flir_confidence = max(flir_confidence, 0.5)
                triggers.append(f"FLIR {sensor_id}: High mean temperature ({sensor_data['t_mean']:.1f}°C)")
                fire_type = "thermal"
            
            if "t_std" in sensor_data and sensor_data["t_std"] > self.flir_thresholds["t_std"]:
                fire_detected = True
                flir_severity = max(flir_severity, 3)
                flir_confidence = max(flir_confidence, 0.4)
                triggers.append(f"FLIR {sensor_id}: High temperature variation ({sensor_data['t_std']:.1f}°C)")
                fire_type = "thermal"
        
        # Analyze SCD41 data
        scd41_severity = 0
        scd41_confidence = 0.0
        
        for sensor_id, sensor_data in scd41_data.items():
            # Check CO2 thresholds
            co2_value = sensor_data.get("gas_val", sensor_data.get("co2_concentration", 0))
            if co2_value > self.scd41_thresholds["gas_val"]:
                fire_detected = True
                scd41_severity = max(scd41_severity, 8)
                scd41_confidence = max(scd41_confidence, 0.9)
                triggers.append(f"SCD41 {sensor_id}: High CO2 ({co2_value:.0f} ppm)")
                fire_type = "chemical"
            
            if "gas_delta" in sensor_data and abs(sensor_data["gas_delta"]) > self.scd41_thresholds["gas_delta"]:
                fire_detected = True
                scd41_severity = max(scd41_severity, 6)
                scd41_confidence = max(scd41_confidence, 0.7)
                triggers.append(f"SCD41 {sensor_id}: Rapid CO2 change ({sensor_data['gas_delta']:.0f} ppm)")
                fire_type = "chemical"
            
            if "gas_vel" in sensor_data and abs(sensor_data["gas_vel"]) > self.scd41_thresholds["gas_vel"]:
                fire_detected = True
                scd41_severity = max(scd41_severity, 5)
                scd41_confidence = max(scd41_confidence, 0.6)
                triggers.append(f"SCD41 {sensor_id}: Rapid CO2 velocity ({sensor_data['gas_vel']:.0f} ppm/s)")
                fire_type = "chemical"
        
        # Combine FLIR and SCD41 analysis
        if flir_severity > 0 and scd41_severity > 0:
            # Both sensors detecting fire - highest confidence
            fire_type = "combined"
            severity = max(flir_severity, scd41_severity)
            confidence = min(0.95, max(flir_confidence, scd41_confidence) + 0.2)
        elif flir_severity > 0:
            # Only FLIR detecting fire
            severity = flir_severity
            confidence = flir_confidence
        elif scd41_severity > 0:
            # Only SCD41 detecting fire
            severity = scd41_severity
            confidence = scd41_confidence
        else:
            # No fire detected
            severity = 0
            confidence = 0.0
        
        return {
            "fire_detected": fire_detected,
            "fire_type": fire_type,
            "severity": severity,
            "confidence": confidence,
            "triggers": triggers,
            "flir_severity": flir_severity,
            "scd41_severity": scd41_severity
        }
    
    def _determine_alert_level(self, severity: int) -> str:
        """
        Determine the alert level based on fire severity.
        
        Args:
            severity: Fire severity (1-10)
            
        Returns:
            Alert level
        """
        if severity >= self.severity_thresholds[FLIRSCD41Alert.LEVEL_EMERGENCY]:
            return FLIRSCD41Alert.LEVEL_EMERGENCY
        elif severity >= self.severity_thresholds[FLIRSCD41Alert.LEVEL_CRITICAL]:
            return FLIRSCD41Alert.LEVEL_CRITICAL
        elif severity >= self.severity_thresholds[FLIRSCD41Alert.LEVEL_WARNING]:
            return FLIRSCD41Alert.LEVEL_WARNING
        else:
            return FLIRSCD41Alert.LEVEL_INFO
    
    def _generate_alert_message(self, fire_type: str, severity: int, alert_level: str, 
                               flir_data: Dict[str, Any], scd41_data: Dict[str, Any]) -> str:
        """
        Generate an alert message based on fire type, severity, and alert level.
        
        Args:
            fire_type: Type of fire
            severity: Fire severity (1-10)
            alert_level: Alert level
            flir_data: FLIR thermal sensor data
            scd41_data: SCD41 gas sensor data
            
        Returns:
            Alert message
        """
        # Get summary information from sensor data
        flir_summary = ""
        scd41_summary = ""
        
        if flir_data:
            flir_sensors = list(flir_data.keys())
            flir_summary = f" (FLIR: {len(flir_sensors)} sensors)"
        
        if scd41_data:
            scd41_sensors = list(scd41_data.keys())
            scd41_summary = f" (SCD41: {len(scd41_sensors)} sensors)"
        
        if alert_level == FLIRSCD41Alert.LEVEL_EMERGENCY:
            return f"EMERGENCY: {fire_type.upper()} fire detected with severity {severity}/10. Immediate evacuation required.{flir_summary}{scd41_summary}"
        elif alert_level == FLIRSCD41Alert.LEVEL_CRITICAL:
            return f"CRITICAL: {fire_type.capitalize()} fire detected with severity {severity}/10. Prepare for evacuation.{flir_summary}{scd41_summary}"
        elif alert_level == FLIRSCD41Alert.LEVEL_WARNING:
            return f"WARNING: Possible {fire_type} fire detected with severity {severity}/10. Investigate immediately.{flir_summary}{scd41_summary}"
        else:
            return f"INFO: Potential {fire_type} fire signature detected with severity {severity}/10. Monitor situation.{flir_summary}{scd41_summary}"
    
    def _should_generate_all_clear(self) -> bool:
        """
        Determine if an all-clear alert should be generated.
        
        Returns:
            True if an all-clear alert should be generated, False otherwise
        """
        # Check if there are any active alerts
        if not self.active_alerts:
            return False
        
        # Check if enough time has passed since the last alert
        all_clear_delay = self.config.get("all_clear_delay_seconds", 300)  # 5 minutes default
        now = datetime.now()
        
        # Find the most recent active alert
        most_recent = max(self.active_alerts.values(), key=lambda a: a.timestamp)
        seconds_since_last_alert = (now - most_recent.timestamp).total_seconds()
        
        return seconds_since_last_alert >= all_clear_delay
    
    def _generate_all_clear_alert(self) -> FLIRSCD41Alert:
        """
        Generate an all-clear alert.
        
        Returns:
            All-clear alert
        """
        alert = FLIRSCD41Alert(
            alert_id=str(uuid.uuid4()),
            timestamp=datetime.now(),
            level=FLIRSCD41Alert.LEVEL_INFO,
            message="ALL CLEAR: No fire detected. Previous alerts have been resolved.",
            source_agent_id=self.agent_id,
            fire_detected=False,
            location=self.location
        )
        
        # Store alert
        self.alerts.append(alert)
        
        # Clear active alerts
        self.active_alerts = {}
        
        logger.info("Generated all-clear alert")
        
        return alert
    
    def _handle_update_thresholds(self, message: Message) -> Optional[Message]:
        """
        Handle a message to update alert thresholds.
        
        Args:
            message: Message containing new threshold values
            
        Returns:
            Optional response message
        """
        content = message.content
        updated = False
        
        # Update severity thresholds
        for level in [FLIRSCD41Alert.LEVEL_INFO, FLIRSCD41Alert.LEVEL_WARNING, 
                     FLIRSCD41Alert.LEVEL_CRITICAL, FLIRSCD41Alert.LEVEL_EMERGENCY]:
            threshold_key = f"{level}_threshold"
            if threshold_key in content:
                new_threshold = content[threshold_key]
                if isinstance(new_threshold, (int, float)) and new_threshold >= 0:
                    self.severity_thresholds[level] = new_threshold
                    updated = True
                    logger.info(f"Updated {level} threshold to {new_threshold}")
                else:
                    logger.error(f"Invalid {level} threshold: {new_threshold}")
        
        # Update confidence threshold
        if "confidence_threshold" in content:
            new_threshold = content["confidence_threshold"]
            if 0 <= new_threshold <= 1:
                self.confidence_threshold = new_threshold
                updated = True
                logger.info(f"Updated confidence threshold to {new_threshold}")
            else:
                logger.error(f"Invalid confidence threshold: {new_threshold}")
        
        # Update FLIR thresholds
        if "flir_thresholds" in content:
            new_thresholds = content["flir_thresholds"]
            if isinstance(new_thresholds, dict):
                self.flir_thresholds.update(new_thresholds)
                updated = True
                logger.info(f"Updated FLIR thresholds: {new_thresholds}")
            else:
                logger.error(f"Invalid FLIR thresholds: {new_thresholds}")
        
        # Update SCD41 thresholds
        if "scd41_thresholds" in content:
            new_thresholds = content["scd41_thresholds"]
            if isinstance(new_thresholds, dict):
                self.scd41_thresholds.update(new_thresholds)
                updated = True
                logger.info(f"Updated SCD41 thresholds: {new_thresholds}")
            else:
                logger.error(f"Invalid SCD41 thresholds: {new_thresholds}")
        
        # Send acknowledgment
        if updated:
            return self.create_message(
                message.sender_id,
                "threshold_update_ack",
                {
                    "severity_thresholds": self.severity_thresholds,
                    "confidence_threshold": self.confidence_threshold,
                    "flir_thresholds": self.flir_thresholds,
                    "scd41_thresholds": self.scd41_thresholds
                }
            )
        else:
            return None
    
    def _handle_acknowledge_alert(self, message: Message) -> Optional[Message]:
        """
        Handle a message to acknowledge an alert.
        
        Args:
            message: Message containing alert acknowledgment
            
        Returns:
            Optional response message
        """
        content = message.content
        
        if "alert_id" not in content or "user_id" not in content:
            logger.error("Missing alert_id or user_id in acknowledge_alert message")
            return self.create_message(
                message.sender_id,
                "acknowledge_alert_nack",
                {
                    "error": "Missing alert_id or user_id"
                }
            )
        
        alert_id = content["alert_id"]
        user_id = content["user_id"]
        
        if alert_id in self.active_alerts:
            alert = self.active_alerts[alert_id]
            alert.acknowledge(user_id)
            
            # Remove from active alerts
            del self.active_alerts[alert_id]
            
            logger.info(f"Alert {alert_id} acknowledged by {user_id}")
            
            return self.create_message(
                message.sender_id,
                "acknowledge_alert_ack",
                {
                    "alert_id": alert_id,
                    "acknowledged": True,
                    "acknowledged_time": alert.acknowledged_time.isoformat(),
                    "acknowledged_by": alert.acknowledged_by
                }
            )
        else:
            logger.warning(f"Attempt to acknowledge unknown alert {alert_id}")
            
            return self.create_message(
                message.sender_id,
                "acknowledge_alert_nack",
                {
                    "alert_id": alert_id,
                    "error": "Alert not found or already acknowledged"
                }
            )
    
    def default_message_handler(self, message: Message) -> Optional[Message]:
        """
        Default handler for message types without a specific handler.
        
        Args:
            message: Incoming message
            
        Returns:
            Optional response message
        """
        logger.warning(f"Received unhandled message type: {message.message_type}")
        return None
    
    def create_message(self, receiver_id: str, message_type: str, content: Dict[str, Any], priority: int = 0) -> Message:
        """
        Create a new message to send to another agent.
        
        Args:
            receiver_id: ID of the receiving agent
            message_type: Type of message
            content: Message content
            priority: Message priority
            
        Returns:
            Created message
        """
        return Message(self.agent_id, receiver_id, message_type, content, priority)
    
    def save_state(self, filepath: str) -> None:
        """
        Save the agent's state to a file.
        
        Args:
            filepath: Path to save the state
        """
        state = {
            "severity_thresholds": self.severity_thresholds,
            "confidence_threshold": self.confidence_threshold,
            "flir_thresholds": self.flir_thresholds,
            "scd41_thresholds": self.scd41_thresholds,
            "location": self.location,
            "alert_count": self.alert_count,
            "alerts": [alert.to_dict() for alert in self.alerts],
            "active_alerts": [alert.to_dict() for alert in self.active_alerts.values()]
        }
        
        with open(filepath, 'w') as f:
            json.dump(state, f, indent=2)
    
    def load_state(self, filepath: str) -> None:
        """
        Load the agent's state from a file.
        
        Args:
            filepath: Path to load the state from
        """
        with open(filepath, 'r') as f:
            state = json.load(f)
        
        self.severity_thresholds = state["severity_thresholds"]
        self.confidence_threshold = state["confidence_threshold"]
        self.flir_thresholds = state["flir_thresholds"]
        self.scd41_thresholds = state["scd41_thresholds"]
        self.location = state["location"]
        self.alert_count = state["alert_count"]
        
        self.alerts = [FLIRSCD41Alert.from_dict(alert_dict) for alert_dict in state["alerts"]]
        
        self.active_alerts = {}
        for alert_dict in state["active_alerts"]:
            alert = FLIRSCD41Alert.from_dict(alert_dict)
            self.active_alerts[alert.alert_id] = alert